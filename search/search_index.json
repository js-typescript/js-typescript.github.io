{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>As a beginner, it\u2019s perfectly fine to stick to just <code>interface</code> initially to build a strong foundation. As you grow more comfortable, experiment with <code>type</code> in scenarios where its flexibility adds value. The goal is to simplify your learning curve while ensuring your code remains maintainable.</p>"},{"location":"#type-and-interface","title":"Type and Interface","text":""},{"location":"#using-type-for-data-models","title":"Using <code>type</code> for Data Models","text":"<p><code>type</code> is a great choice for complex types like unions or intersections, especially when working with API responses.</p> Typescript<pre><code>// API Response Type\ntype Role = \"admin\" | \"editor\" | \"viewer\"; // Union type\n\ntype User = {\n  id: number;\n  name: string;\n  email: string;\n  role: Role; // Union type used here\n  isActive: boolean;\n};\n\n// Intersection Type (Combining two models)\ntype Timestamps = {\n  createdAt: string;\n  updatedAt: string;\n};\n\ntype UserWithTimestamps = User &amp; Timestamps; // Combining User and Timestamps\n\n// Example usage\nconst exampleUser: UserWithTimestamps = {\n  id: 1,\n  name: \"John Doe\",\n  email: \"john.doe@example.com\",\n  role: \"admin\",\n  isActive: true,\n  createdAt: \"2025-04-09T12:34:56Z\",\n  updatedAt: \"2025-04-09T15:20:00Z\",\n};\n</code></pre>"},{"location":"#using-interface-for-component-props","title":"Using <code>interface</code> for Component Props","text":"<p><code>interface</code> works well for describing props, especially when you want to extend or merge interfaces.</p> Typescript<pre><code>// Base Props\ninterface CommonProps {\n  id: number;\n  isActive: boolean;\n}\n\n// Component-Specific Props\ninterface UserCardProps extends CommonProps {\n  name: string;\n  role: Role; // Reusing Role type\n}\n\n// UserCard Component\nconst UserCard: React.FC&lt;UserCardProps&gt; = ({ id, name, role, isActive }) =&gt; {\n  return (\n    &lt;div&gt;\n      &lt;h3&gt;{name}&lt;/h3&gt;\n      &lt;p&gt;Role: {role}&lt;/p&gt;\n      &lt;p&gt;Status: {isActive ? \"Active\" : \"Inactive\"}&lt;/p&gt;\n    &lt;/div&gt;\n  );\n};\n\n// Example usage\nconst App: React.FC = () =&gt; (\n  &lt;UserCard id={1} name=\"John Doe\" role=\"admin\" isActive={true} /&gt;\n);\n</code></pre>"},{"location":"#mixing-them-in-a-single-project","title":"Mixing Them in a Single Project","text":"<p>While it\u2019s common to use both <code>type</code> and <code>interface</code> in the same codebase, here\u2019s a guiding principle:</p> <ul> <li>Use <code>type</code> for defining data models, like the shape of API responses.</li> <li>Use <code>interface</code> for defining component props, especially when you anticipate extending or merging definitions.</li> </ul>"},{"location":"#suggested-workflow-for-your-project","title":"Suggested Workflow for Your Project","text":"<p>Here\u2019s a step-by-step guide tailored to your first project:</p> <ol> <li> <p>Component Props: Use <code>interface</code> for all component props.</p> Typescript<pre><code>interface ButtonProps {\n  label: string;\n  onClick: () =&gt; void;\n  disabled?: boolean;\n}\n</code></pre> </li> <li> <p>Data Models: Use <code>interface</code> for simple objects and try <code>type</code> for anything complex.</p> Typescript<pre><code>type ApiResponse = {\n  status: \"success\" | \"error\";\n  data: { id: number; name: string }[];\n};\n</code></pre> </li> <li> <p>Consistency: Stick to the same convention (e.g., all props use <code>interface</code>) for consistency across the project.</p> </li> </ol>"},{"location":"#example-of-gradual-transition","title":"Example of Gradual Transition","text":"<p>Here\u2019s how you might evolve your usage of <code>type</code> and <code>interface</code> as your project grows:</p> <ul> <li> <p>Start: Use <code>interface</code> for everything:</p> Typescript<pre><code>interface User {\n  id: number;\n  name: string;\n}\n</code></pre> </li> <li> <p>Later: Use <code>type</code> when you encounter more advanced scenarios:</p> Typescript<pre><code>type User = { id: number; name: string } &amp; { email: string };\n</code></pre> </li> </ul> <p>As a beginner, it\u2019s perfectly fine to stick to just <code>interface</code> initially to build a strong foundation. As you grow more comfortable, experiment with <code>type</code> in scenarios where its flexibility adds value. The goal is to simplify your learning curve while ensuring your code remains maintainable.</p>"},{"location":"#reference","title":"Reference","text":"<ul> <li>\u2728\u267b\ufe0f JavaScript Visualized: Event Loop </li> <li>Visualized</li> </ul>"},{"location":"blog/","title":"Index","text":""},{"location":"blog/#blog","title":"Blog","text":""},{"location":"typescript/folder-structure/","title":"Folder Structure","text":"<p>Great \u2014 it's awesome that you've already built a large banking treasury web application with React and Ant Design!== Transitioning to TypeScript (TS)== is a wise move, especially for large codebases where type safety helps reduce bugs and improve maintainability.</p> <p>Let's walk you through how to set up a scalable, feature-based folder structure in TypeScript, along with how to transition your existing code.</p>"},{"location":"typescript/folder-structure/#feature-based-folder-structure-with-typescript","title":"\ud83d\uddc2\ufe0f Feature-Based Folder Structure (with TypeScript)","text":"<p>Here's a standard and scalable folder structure:</p> <pre><code>src/\n\u251c\u2500\u2500 app/                  # Application setup: store, routes, etc.\n\u2502   \u251c\u2500\u2500 store.ts\n\u2502   \u2514\u2500\u2500 App.tsx\n\u2502\n\u251c\u2500\u2500 features/             # Feature-based folders\n\u2502   \u251c\u2500\u2500 accounts/\n\u2502   \u2502   \u251c\u2500\u2500 components/   # UI components specific to \"accounts\"\n\u2502   \u2502   \u251c\u2500\u2500 hooks/        # Custom hooks\n\u2502   \u2502   \u251c\u2500\u2500 types/        # TypeScript types/interfaces\n\u2502   \u2502   \u251c\u2500\u2500 services/     # API calls or service functions\n\u2502   \u2502   \u251c\u2500\u2500 pages/        # Pages (used in routes)\n\u2502   \u2502   \u2514\u2500\u2500 index.ts      # Barrel export\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 payments/\n\u2502       \u251c\u2500\u2500 ...\n\u2502\n\u251c\u2500\u2500 shared/               # Shared UI components, utils, hooks\n\u2502   \u251c\u2500\u2500 components/\n\u2502   \u251c\u2500\u2500 hooks/\n\u2502   \u251c\u2500\u2500 utils/\n\u2502   \u2514\u2500\u2500 types/\n\u2502\n\u251c\u2500\u2500 assets/               # Static files (images, fonts, etc.)\n\u2502\n\u251c\u2500\u2500 index.tsx\n\u2514\u2500\u2500 react-app-env.d.ts    # Environment types\n</code></pre> <p>\ud83e\udde9 Example: <code>features/accounts</code></p> <pre><code>features/\n\u2514\u2500\u2500 accounts/\n    \u251c\u2500\u2500 components/\n    \u2502   \u2514\u2500\u2500 AccountCard.tsx\n    \u251c\u2500\u2500 hooks/\n    \u2502   \u2514\u2500\u2500 useAccountDetails.ts\n    \u251c\u2500\u2500 pages/\n    \u2502   \u2514\u2500\u2500 AccountDetailsPage.tsx\n    \u251c\u2500\u2500 services/\n    \u2502   \u2514\u2500\u2500 accountService.ts\n    \u251c\u2500\u2500 types/\n    \u2502   \u2514\u2500\u2500 account.types.ts\n    \u2514\u2500\u2500 index.ts\n</code></pre> <p>Example: <code>account.types.ts</code></p> <pre><code>export interface Account {\n  id: string;\n  name: string;\n  balance: number;\n  currency: string;\n}\n</code></pre> <p>Example: <code>accountService.ts</code></p> <pre><code>import { Account } from \"../types/account.types\";\n\nexport const fetchAccount = async (id: string): Promise&lt;Account&gt; =&gt; {\n  const res = await fetch(`/api/accounts/${id}`);\n  return res.json();\n};\n</code></pre> <p>\ud83e\udde0 Tips for Migrating to TS</p> <ul> <li>Start with <code>types/interfaces</code> for your API data models.</li> <li>Create shared types under <code>shared/types/</code> if used across features.</li> <li>Use <code>React.FC&lt;Props&gt;</code> or explicit function types for components.</li> <li>Gradually migrate one feature folder at a time.</li> </ul> <p>\ud83d\udee0\ufe0f Dev Tools (Optional but Recommended)</p> <ul> <li>ESLint with TypeScript rules</li> <li>Prettier</li> <li> <p>Path aliases in <code>tsconfig.json</code>:</p> <pre><code>\"paths\": {\n  \"@app/*\": [\"src/app/*\"],\n  \"@features/*\": [\"src/features/*\"],\n  \"@shared/*\": [\"src/shared/*\"]\n}\n</code></pre> <p>Then import like:</p> <pre><code>import { AccountCard } from \"@features/accounts/components\";\n</code></pre> </li> </ul> <p>\ud83e\uddf1 Component Typing Example</p> <pre><code>// props defined in separate type file or inline\ntype AccountCardProps = {\n  name: string;\n  balance: number;\n};\n\nconst AccountCard: React.FC&lt;AccountCardProps&gt; = ({ name, balance }) =&gt; (\n  &lt;div&gt;\n    &lt;h2&gt;{name}&lt;/h2&gt;\n    &lt;p&gt;Balance: ${balance}&lt;/p&gt;\n  &lt;/div&gt;\n);\n</code></pre> <p>\ud83d\udccc Summary</p> <p>You now have:</p> <ul> <li>\u2705 TypeScript installed</li> <li>\u2705 A scalable feature-based folder structure</li> <li>\u2705 Clear guidance on splitting logic by domain</li> <li>\u2705 Type-safe components, services, and pages</li> </ul>"},{"location":"typescript/folder-structure/#full-folderfile-structure","title":"\ud83d\udcc1 Full Folder/File Structure","text":"<p>Here\u2019s a refined TypeScript + Feature-Based structure:</p> <pre><code>src/\n\u251c\u2500\u2500 app/                        # App setup: routing, store, layout\n\u2502   \u251c\u2500\u2500 App.tsx\n\u2502   \u251c\u2500\u2500 routes.tsx\n\u2502   \u251c\u2500\u2500 store.ts\n\u2502   \u251c\u2500\u2500 theme.ts                # Ant Design theme customization\n\u2502   \u2514\u2500\u2500 index.ts                # Barrel for exports\n\n\u251c\u2500\u2500 features/                   # All domain features here\n\u2502   \u251c\u2500\u2500 accounts/\n\u2502   \u2502   \u251c\u2500\u2500 components/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 AccountCard.tsx\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 AccountList.tsx\n\u2502   \u2502   \u251c\u2500\u2500 hooks/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 useAccountDetails.ts\n\u2502   \u2502   \u251c\u2500\u2500 pages/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 AccountDetailsPage.tsx\n\u2502   \u2502   \u251c\u2500\u2500 services/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 accountService.ts\n\u2502   \u2502   \u251c\u2500\u2500 types/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 account.types.ts\n\u2502   \u2502   \u2514\u2500\u2500 index.ts\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 payments/\n\u2502   \u2502   \u251c\u2500\u2500 components/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 PaymentForm.tsx\n\u2502   \u2502   \u251c\u2500\u2500 hooks/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 usePaymentValidation.ts\n\u2502   \u2502   \u251c\u2500\u2500 pages/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 CreatePaymentPage.tsx\n\u2502   \u2502   \u251c\u2500\u2500 services/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 paymentService.ts\n\u2502   \u2502   \u251c\u2500\u2500 types/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 payment.types.ts\n\u2502   \u2502   \u2514\u2500\u2500 index.ts\n\n\u251c\u2500\u2500 shared/                     # Reusable across features\n\u2502   \u251c\u2500\u2500 components/\n\u2502   \u2502   \u251c\u2500\u2500 Loader.tsx\n\u2502   \u2502   \u2514\u2500\u2500 ModalWrapper.tsx\n\u2502   \u251c\u2500\u2500 hooks/\n\u2502   \u2502   \u2514\u2500\u2500 useDebounce.ts\n\u2502   \u251c\u2500\u2500 utils/\n\u2502   \u2502   \u2514\u2500\u2500 formatCurrency.ts\n\u2502   \u2514\u2500\u2500 types/\n\u2502       \u2514\u2500\u2500 common.types.ts\n\n\u251c\u2500\u2500 assets/                     # Images, fonts, etc.\n\u2502   \u251c\u2500\u2500 images/\n\u2502   \u2502   \u2514\u2500\u2500 logo.png\n\u2502   \u2514\u2500\u2500 styles/\n\u2502       \u2514\u2500\u2500 global.less\n\n\u251c\u2500\u2500 docs/                       # Internal docs (OPTIONAL)\n\u2502   \u251c\u2500\u2500 architecture.md\n\u2502   \u251c\u2500\u2500 api-contracts.md\n\u2502   \u2514\u2500\u2500 README.md\n\n\u251c\u2500\u2500 index.tsx                   # Entry point\n\u251c\u2500\u2500 react-app-env.d.ts          # React type extensions (auto-generated)\n\u2514\u2500\u2500 vite-env.d.ts / env.d.ts    # (if using Vite or custom envs)\n</code></pre>"},{"location":"typescript/folder-structure/#naming-conventions","title":"\ud83e\uddfe Naming Conventions","text":"<p>\u2705 File Naming</p> Purpose Convention Example Components <code>PascalCase.tsx</code> <code>AccountCard.tsx</code> Hooks <code>camelCase.ts</code> <code>useAccountDetails.ts</code> Utils <code>camelCase.ts</code> <code>formatCurrency.ts</code> Services <code>camelCase.ts</code> <code>accountService.ts</code> Types <code>kebab-case.types.ts</code> or <code>camelCase.types.ts</code> <code>account.types.ts</code> Pages <code>PascalCase.tsx</code> <code>AccountDetailsPage.tsx</code> Barrel Files <code>index.ts</code> <code>index.ts</code> in each folder <p>Tip: Keep each component/hook/type in a separate file unless it\u2019s trivial.</p> <p>\u2705 Folder Naming</p> Type Convention Example Features <code>camelCase</code> <code>accounts</code>, <code>payments</code> Subfolders <code>camelCase</code> <code>components</code>, <code>services</code>, <code>types</code> Shared <code>shared/</code> Shared modules used across features Assets <code>assets/</code> Images, styles, icons Docs <code>docs/</code> Internal team documentation"},{"location":"typescript/folder-structure/#docs-folder-for-documentation","title":"\ud83d\uddc2\ufe0f <code>docs/</code> Folder (for documentation)","text":"<p>Optional but very useful if you're working in a team or managing a large project.</p> <pre><code>docs/\n\u251c\u2500\u2500 architecture.md       # Explains the folder structure, app layers\n\u251c\u2500\u2500 api-contracts.md      # API response/request examples &amp; schemas\n\u251c\u2500\u2500 environment.md        # Notes on .env setup or build config\n\u2514\u2500\u2500 README.md             # Overview and how to start dev\n</code></pre> <p>Keep <code>docs/</code> out of <code>src/</code> \u2014 it's not part of the runtime code.</p>"},{"location":"typescript/folder-structure/#bonus-barrel-export-indexts","title":"\ud83e\udde0 Bonus: Barrel Export (<code>index.ts</code>)","text":"<p>Each feature folder can export its public APIs using <code>index.ts</code>:</p> <pre><code>// features/accounts/index.ts\nexport * from \"./services/accountService\";\nexport * from \"./types/account.types\";\nexport * from \"./components/AccountCard\";\n</code></pre> <p>So you can import like:</p> <pre><code>import { fetchAccount } from \"@features/accounts\";\n</code></pre> <p>\ud83d\udccc Summary</p> <p>Your codebase will be:</p> <ul> <li>\u2705 Scalable</li> <li>\u2705 Maintainable</li> <li>\u2705 Type-safe</li> <li>\u2705 Organized by feature/domain, not technical layers</li> </ul> <p>If you'd like, I can generate a full starter project scaffold in TypeScript matching this structure, or help refactor your existing code into this structure gradually.</p>"},{"location":"typescript/folder-structure/#question","title":"Question","text":"<p>can i add <code>tsx</code> file in <code>shared/utils</code> or not? </p> <p>Great question \u2014 and the short answer is:</p>"},{"location":"typescript/folder-structure/#you-should-avoid-using-tsx-files-inside-sharedutils","title":"\u274c You should avoid using <code>.tsx</code> files inside shared/utils/","text":"<p>\u2705 Why?</p> <p><code>utils/</code> is meant for pure logic functions \u2014 no JSX, no React.</p> <p>These are typically:</p> <ul> <li>Utility functions</li> <li>Formatters</li> <li>Validators</li> <li>Converters</li> <li>Date helpers</li> <li>API helpers (non-UI)</li> </ul> <p><code>tsx</code> files are for components (they include JSX).</p> <p>So if you're putting a <code>.tsx</code> file in <code>shared/utils/</code>, you're likely mixing UI with logic, which breaks the separation of concerns.</p> <p>\u2705 Correct Usage Examples</p> <p>\u2714\ufe0f <code>shared/utils/formatCurrency.ts</code></p> <pre><code>export const formatCurrency = (amount: number) =&gt;\n  new Intl.NumberFormat(\"en-US\", {\n    style: \"currency\",\n    currency: \"USD\",\n  }).format(amount);\n</code></pre> <p>\u2714\ufe0f <code>shared/components/LoadingSpinner.tsx</code></p> <pre><code>import React from \"react\";\nimport { Spin } from \"antd\";\n\nexport const LoadingSpinner = () =&gt; &lt;Spin /&gt;;\n</code></pre> <p>\u274c Wrong Example</p> <pre><code>// \ud83d\udeab shared/utils/LoadingSpinner.tsx  (don't do this)\n\nimport { Spin } from \"antd\";\n\nconst LoadingSpinner = () =&gt; &lt;Spin /&gt;;\nexport default LoadingSpinner;\n</code></pre> <p>Instead, move it to:</p> <pre><code>shared/components/LoadingSpinner.tsx\n</code></pre> <p>\ud83e\udde0 Rule of Thumb</p> Folder JS/TS JSX/TSX Purpose <code>utils/</code> \u2705 \u274c Pure logic, no UI <code>components/</code> \u2705 \u2705 UI Components <code>hooks/</code> \u2705 \u2705 Custom React hooks <p>\u2705 Recommendation</p> <p>If you're trying to create something reusable and it uses JSX (like a loading spinner, modal wrapper, etc), always place it in:</p> <pre><code>shared/components/\n</code></pre> <p>Keep <code>shared/utils/</code> for plain functions only.</p>"},{"location":"typescript/intro/","title":"Intro","text":""},{"location":"typescript/react-js-to-ts-migration-guide/","title":"Migrating from React JavaScript to TypeScript: A Beginner's Guide","text":"<p>Transitioning from React with plain JavaScript to TypeScript is a big step, and it's one that brings great long-term benefits (type safety, better IDE support, fewer bugs).</p> <p>But yes, there are important things to keep in mind during the switch \u2014 and I\u2019ll walk you through them as a beginner, in practical, clear terms.</p>"},{"location":"typescript/react-js-to-ts-migration-guide/#overview","title":"Overview","text":""},{"location":"typescript/react-js-to-ts-migration-guide/#1-you-dont-have-to-convert-everything-at-once","title":"1. You Don\u2019t Have to Convert Everything at Once","text":"<p>You can incrementally migrate your codebase. Thanks to this setting in tsconfig.json:</p> <pre><code>\"allowJs\": true\n</code></pre> <p>This allows <code>.js</code> files to coexist with <code>.ts</code> and <code>.tsx</code> files. So start small \u2014 convert one component, one hook, or one feature at a time.</p>"},{"location":"typescript/react-js-to-ts-migration-guide/#2-understand-the-file-types","title":"2. Understand the File Types","text":"File Type Purpose <code>.ts</code> TypeScript file \u2014 logic-only (no JSX) <code>.tsx</code> TypeScript + JSX \u2014 used for React components <code>.d.ts</code> Declaration files \u2014 used for defining types for external JS packages (usually not written manually at first) <p>\u2757 Never use <code>.ts</code> for a component. If it has JSX, use <code>.tsx</code>.</p>"},{"location":"typescript/react-js-to-ts-migration-guide/#3-type-your-props-react-components","title":"3. Type Your Props (React Components)","text":"<p>Here\u2019s how to write component props in TypeScript:</p> <p>Old (JS):</p> <pre><code>function Button({ label }) {\n  return &lt;button&gt;{label}&lt;/button&gt;;\n}\n</code></pre> <p>New (TS):</p> <pre><code>type ButtonProps = {\n  label: string;\n};\n\nconst Button: React.FC&lt;ButtonProps&gt; = ({ label }) =&gt; {\n  return &lt;button&gt;{label}&lt;/button&gt;;\n};\n</code></pre>"},{"location":"typescript/react-js-to-ts-migration-guide/#4-type-your-state-and-variables","title":"4. Type Your State and Variables","text":"<p>JS:</p> <pre><code>const [amount, setAmount] = useState(0);\n</code></pre> <p>TS:</p> <pre><code>const [amount, setAmount] = useState&lt;number&gt;(0);\n</code></pre> <p>But TypeScript can often infer types. For example:</p> <pre><code>const [name, setName] = useState(\"John\"); // inferred as string\n</code></pre> <p>Use explicit typing when:</p> <ul> <li>You initialize with <code>null</code> or <code>undefined</code></li> <li>The type is complex (objects, arrays, etc.)</li> </ul> <pre><code>const [user, setUser] = useState&lt;User | null&gt;(null);\n</code></pre>"},{"location":"typescript/react-js-to-ts-migration-guide/#5-typing-api-responses","title":"5. Typing API Responses","text":"<p>Don\u2019t just use <code>any</code>. Define types for your API data:</p> <pre><code>// types/user.types.ts\nexport interface User {\n  id: number;\n  name: string;\n  email: string;\n}\n</code></pre> <p>Then use it:</p> <pre><code>const fetchUser = async (): Promise&lt;User&gt; =&gt; {\n  const res = await fetch(\"/api/user\");\n  return res.json();\n};\n</code></pre>"},{"location":"typescript/react-js-to-ts-migration-guide/#6-avoid-any-unless-youre-desperate","title":"6. Avoid <code>any</code> Unless You're Desperate","text":"<p>TypeScript allows this:</p> <pre><code>let data: any;\n</code></pre> <p>But try to avoid it. You lose all type safety. Prefer <code>unknown</code> or actual types.</p>"},{"location":"typescript/react-js-to-ts-migration-guide/#7-typescript-with-events-forms-refs-etc","title":"7. TypeScript with Events, Forms, Refs, etc.","text":"<p>These are tricky for beginners \u2014 here are common ones:</p> <p>Event (e.g., onChange):</p> <pre><code>const handleChange = (e: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {\n  console.log(e.target.value);\n};\n</code></pre> <p>Form Submit:</p> <pre><code>const handleSubmit = (e: React.FormEvent&lt;HTMLFormElement&gt;) =&gt; {\n  e.preventDefault();\n};\n</code></pre> <p>useRef:</p> <pre><code>const inputRef = useRef&lt;HTMLInputElement&gt;(null);\n</code></pre>"},{"location":"typescript/react-js-to-ts-migration-guide/#8-typescript-with-ant-design","title":"8. TypeScript with Ant Design","text":"<p>AntD components are already typed. You can often let the type inference work for you:</p> <pre><code>&lt;Form.Item name=\"email\" label=\"Email\"&gt;\n  &lt;Input /&gt;\n&lt;/Form.Item&gt;\n</code></pre> <p>But for custom handlers or complex forms, you might want to define types for form values.</p> <pre><code>interface FormValues {\n  email: string;\n  password: string;\n}\n</code></pre>"},{"location":"typescript/react-js-to-ts-migration-guide/#9-use-type-aliases-or-interfaces","title":"9. Use Type Aliases or Interfaces","text":"<p>They\u2019re almost the same for most use cases:</p> <pre><code>type User = {\n  name: string;\n  age: number;\n};\n\ninterface Product {\n  name: string;\n  price: number;\n}\n</code></pre> <p>Stick to <code>type</code> for data and <code>interface</code> for classes or props, but it\u2019s mostly preference unless doing advanced stuff.</p>"},{"location":"typescript/react-js-to-ts-migration-guide/#10-leverage-your-ide-vs-code","title":"\u2705 10. Leverage Your IDE (VS Code)","text":"<p>TypeScript really shines when you:</p> <ul> <li>Hover to see inferred types</li> <li>Get red squiggles for errors</li> <li>Use auto-imports and definitions</li> </ul>"},{"location":"typescript/react-js-to-ts-migration-guide/#pro-tip-set-up-strict-type-checking","title":"\ud83e\udde0 Pro Tip: Set Up Strict Type Checking","text":"<p>In your <code>tsconfig.json</code>, set:</p> <pre><code>\"strict\": true\n</code></pre> <p>This gives you maximum safety \u2014 it\u2019ll force you to be explicit and avoid runtime issues.</p>"},{"location":"typescript/react-js-to-ts-migration-guide/#summary-what-to-focus-on-first","title":"Summary: What to Focus On First","text":"Priority What to Learn/Do \u2b50\ufe0f\u2b50\ufe0f\u2b50\ufe0f Typing props, state, and event handlers \u2b50\ufe0f\u2b50\ufe0f Creating and using custom types/interfaces \u2b50\ufe0f Typing API responses and forms \u2705 Using <code>.tsx</code> for components, <code>.ts</code> for logic \u274c Avoid using <code>any</code> unless needed"},{"location":"typescript/type-only-imports-typescript/","title":"Understanding Type-Only Imports in TypeScript","text":"<p>In TypeScript, the <code>type</code> keyword in an import like:</p> <pre><code>import type { Message } from \"./message.types\";\n</code></pre> <p>is not required, but it is recommended in certain situations. Let's break it down:</p>"},{"location":"typescript/type-only-imports-typescript/#what-does-import-type-do","title":"What does <code>import type</code> do?","text":"<p><code>import type</code> tells TypeScript explicitly that you are only importing types, not runtime values.</p> <p>This has two main benefits:</p> <ol> <li> <p>Tree-shaking and optimization</p> <p>When you use <code>import type</code>, the imported type is completely erased from the JavaScript output during compilation, since types don't exist at runtime. This can improve tree-shaking and reduce bundle size.</p> </li> <li> <p>Avoids circular dependencies and side effects</p> <p>Since <code>import type</code> never brings in runtime code, it's safe from accidentally triggering side effects or circular imports.</p> </li> </ol>"},{"location":"typescript/type-only-imports-typescript/#without-type-keyword","title":"\ud83d\udd04 Without <code>type</code> keyword","text":"<p>If you do this:</p> <pre><code>import { Message } from \"./message.types\";\n</code></pre> <p>It still works fine as long as <code>Message</code> is a type, but now TypeScript can't guarantee that the import has no runtime effect. So:</p> <ul> <li>The compiler keeps the import in the compiled JavaScript (even though it's just a type).</li> <li>This can sometimes lead to unwanted side effects or circular dependencies.</li> </ul>"},{"location":"typescript/type-only-imports-typescript/#so-is-it-required","title":"\ud83e\udde0 So, is it required?","text":"Scenario <code>import type</code> Required? Explanation TypeScript file (<code>.ts</code> or <code>.tsx</code>) \u274c Not strictly required But recommended for type-only imports When using <code>isolatedModules</code> or Babel \u2705 Yes Because the compiler needs to know it's a type-only import for correct transpilation"},{"location":"typescript/type-only-imports-typescript/#best-practice","title":"\u2705 Best Practice","text":"<p>Use <code>import type</code> whenever you're importing types only. It's a good habit that improves code clarity and avoids potential pitfalls.</p>"},{"location":"typescript/type-only-imports-typescript/#example","title":"Example","text":"<pre><code>export type Message = {\n  id: string;\n  authorId: string;\n  text: string;\n  createdAt: string;\n};\n</code></pre> <pre><code>// Good: Only imports type, won't be in compiled JS\nimport type { Message } from \"./message.types\";\n\nexport type ChatInput = {\n  messages: Message[];\n  currentUserId: string;\n  readAt?: string;\n};\n</code></pre>"},{"location":"typescript/type-only-imports-typescript/#naming-convention","title":"Naming Convention","text":""},{"location":"typescript/type-only-imports-typescript/#1-filename-naming-convention-for-typescript-files","title":"\ud83d\udcc4 1. Filename Naming Convention (for TypeScript files)","text":"<p>\u2705 Recommended:</p> <p>Use kebab-case (lowercase with hyphens) for filenames, which is common in many TypeScript projects.</p> <p>Examples:</p> Description Filename Type definitions for messages <code>message.types.ts</code> Type definitions for chat <code>chat.types.ts</code> Shared types <code>shared.types.ts</code> API request types <code>api-request.types.ts</code> <p>Alternatives:</p> <ul> <li>Some teams use camelCase or PascalCase, but <code>kebab-case</code> is the most readable and conventional in open source and monorepo setups.</li> </ul>"},{"location":"typescript/type-only-imports-typescript/#2-type-name-naming-convention","title":"\ud83c\udff7\ufe0f 2. Type Name Naming Convention","text":"<p>\u2705 Recommended:</p> <p>Use PascalCase for all TypeScript type aliases and interfaces.</p> <ul> <li>This aligns with the naming of classes and types in general.</li> </ul> <p>Examples:</p> <pre><code>// \u2705 PascalCase\nexport type ChatInput = { ... };\n\nexport interface Message { ... };\n\nexport type UserId = string;\n</code></pre> <p>\u274c Avoid:</p> <pre><code>// \u274c lowercase or snake_case\nexport type chat_input = { ... };\nexport type chatinput = { ... };\n</code></pre>"},{"location":"typescript/type-only-imports-typescript/#summary","title":"Summary","text":"Element Convention Example Filename <code>kebab-case</code> <code>chat-input.types.ts</code> Type name <code>PascalCase</code> <code>ChatInput</code>"}]}